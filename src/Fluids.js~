import React, { useEffect } from 'react';
import VertexSinDemo from './demos/VertexSin';
import Sin3Demo from './demos/Sin3';
import { vert_sinnoise, frag_sinnoise } from './shaders/shad_sinnoise';
import Image from 'next/image'
import Prism from 'prismjs'

export default function Fluids() {
  const t1 = 'Under the hood a rendered 3D-model includes a collection of vertices, where a vertex can have' +
	' attributes including but not limited to its position in space.  Vertex shaders can manipulate ' +
	'vertex attributes, ex you can use them to make a fluid effect on a surface.  The idea is basically' +
	' to sample 2D noise for the magnitude of a vector normal to the surface to be added to ' +
	'the position, for each vertex.  Sampling the noise periodically you can get moving patterns.';
  const t2 = 'This is what the effect looks like rendered as a grayscale image.'
  const t3 = 'The shader.'
  const t4 = 'You\'ve probably figured out the noise is generated by the sum of two terms coming from sin ' +
	'waves along the two axes of the image.  The shader includes a time component offset for each wave ' +
	'inducing the oscillation.  Cool effect though we can do better.  The crux of the matter is of course' +
	' the function used to generate the noise.  Im thinking that we ought to consider whether or not this' +
	' should be done on the CPU or the GPU.  The thing is, if we can get a nice algorithm to generate ' +
	'noise on a per pixel basis, allowing us to parallelize the process on the GPU, then we can take ' +
	'advantage of the relevant performance benefits.  Then again, as the old saying goes, \"Don\'t ' +
	'optimize yet,\" and my intuition about this problem says it\'s likely to be an iterative procedure' +
	' that might be cumbersome to implement in a shader, so I\'m going to compile a wasm module from Rust' +
	' to generate some cool ocean waves.  We\'ll be going off of the algorithm described in this paper, ' +
	'which is well worth a read.'

  useEffect(() => {
    if(typeof window !== 'undefined') {
      Prism.highlightAll();
    }
  }, []);
	
  return (
    <div className="fluids">
      <p>{t1}</p>
      <VertexSinDemo></VertexSinDemo>
      <pre class="language-clike" >
        <code>
          {vert_sinnoise}
        </code>
      </pre>
      <p>{t3}</p>
      <div className="noise">
        <Image src="/noise_sin.png" width="512" height="512"/>
      </div>
      <p>{t2}</p>
      <p>{t4}</p>
      <Sin3Demo></Sin3Demo>
    </div>
  );
}
